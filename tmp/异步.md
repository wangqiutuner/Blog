# JavaScript中的异步

**q_qiu**：JavaScript的一大特点就是单线程

作为JS三座大山（原型、作用域/闭包、异步）之一。异步和 `event-loop` （事件轮询）是密不可分的。它能体现出单线程中异步操作是如何被执行的。关于 `event-loop` 可以参考阮一峰老师的这篇文章《[什么是eventloop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)》。

## 一、宏任务与微任务

微任务的优先级高于宏任务。

<table summary="宏任务">
<caption>宏任务</caption>
<tr>
    <th>#</th>
    <th>浏览器</th>
    <th>Node</th>
</tr>
<tr>
    <td><code>I/O</code></td>
    <td>✔</td>
    <td>✔</td>
</tr>
<tr>
    <td><code>setTimeout</code></td>
    <td>✔</td>
    <td>✔</td>
</tr>
<tr>
    <td><code>setInterval</code></td>
    <td>✔</td>
    <td>✔</td>
</tr>
<tr>
    <td><code>setImmediate</code></td>
    <td>✖</td>
    <td>✔</td>
</tr>
<tr>
    <td><code>requestAnimationFrame</code></td>
    <td>✔</td>
    <td>✖</td>
</tr>
</table>

<table summary="微任务">
<caption>微任务</caption>
<tr>
    <th>#</th>
    <th>浏览器</th>
    <th>Node</th>
</tr>
<tr>
    <td><code>process.nextTick</code></td>
    <td>✖</td>
    <td>✔</td>
</tr>
<tr>
    <td><code>MutationObserver</code></td>
    <td>✔</td>
    <td>✖</td>
</tr>
<tr>
    <td><code>Promise.then catch finally</code></td>
    <td>✔</td>
    <td>✔</td>
</tr>
</table>

## 二、异步callbacks

假如这里有一个异步函数和一个非异步函数

```javascript
var a,b;

function f1(){
  setTimeout(function(){
    a = 1;
    console.log(`a=${a}`);
  },1000);
}
function f2(){
    b = a + 1;
    console.log(`b=${b}`);
}
```

我们需要 `f2` 在 `f1` 之后执行，`b` 的计算需要 `f1` 中对 `a` 的计算结果。可以把 `f1` 当成一个包含ajax请求的函数，而 `f2` 中需要 `f1` 中返回的结果。最简单的我们可能会这样操作：

```javascript
function f1(){
  setTimeout(function(){
    var a = 1;
    console.log(`a=${a}`);
    f2(a);
  },1000);
}

function f2(a){
    var b = a + 1;
    console.log(`b=${b}`);
}

f1();
```

这样的话 `f2` 被写死在了 `f1` 里面，不具有扩展性。通过 `callbacks` 的方式便可以令上述的函数稍微具有一定的扩展性。

```javascript
// 给异步函数设置回调函数
function f1(callback){
  setTimeout(function(){
    var a = 1;
    console.log(`a=${a}`);
    callback(a);
  },1000);
}

// 函数声明的方式
function f2(a){
    var b = a + 1;
    console.log(`b=${b}`);
}

f1(f2);

// 匿名函数的方式，大多采用的方式
f1(function(a){
    console.log(`b=${a+2}`);
})
```

然而假如说有很多顺序执行的异步函数的话，就会产生回调地狱。

```javascript
// f1,f2是两个异步函数
function f1(callback){
  setTimeout(function(){
    a...
    callback(a);    // a是异步处理的结果
  },1000);
}

// b经过处理后作为回调函数的参数
function f2(callback,b){
    setTimeout(function(){
    b...
    callback(b);    // b是异步处理的结果
  },1000);
}

// f3， f4 是两个同步函数
function f3(c){
    c...
}

function f4(d){
    d...
}

// 使用匿名函数作为回调函数
f1(function(x){
    x...
    f3(x);
    f2(function(y){
        y...
        f4(y);
    },x);
})
```

上面的函数执行顺序为`f1()` -> `f3()` -> `f2()` -> `f4()`，其中 `f2()` 和 `f3()` 用到了 `f1()` 的处理结果，`f4()` 用到了 `f2()` 的处理结果。这种嵌套的书写方式跟人线性的思考方式相违和,并且会使代码变得很乱，难以维护和更新。

## 三、Promise

`Promise` 是专门为异步操作而设计的。同样是上边的例子

```javascript
// f1,f2封装两个异步函数
function f1(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            a...
            resolve(a);      // a是异步处理的结果
        },1000);
    });
}

function f2(b){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            b...
            resolve(b);      // b是异步处理的结果
        },1000);
    });
}

// f3， f4 是两个同步函数
function f3(c){
    c...
}

function f4(d){
    d...
}

// 使用Promise处理异步
f1(function(a){
    a...
    f3();
    f2(function(b){
        b...
        f4();
    });
})

f1.then(function(x){
    x...
    f3(x);
    return Promise.resolve(f2(x));
}).then(function(y){
    y...
    f4(y);
})
```

使用 `Promise` 在一定程度上增加了代码的可读性。在使用 `Promise` 时请注意一下几点

- 使用 `Promise` 封装异步时，将异步操作放到 `Promise` 对象中并返回这个 `Promise` 对象
- `then()` 方法中 永远 `return` 或 `throw`
- 如果 `promise` 链中可能出现错误，一定添加 `catch`
- 永远传递函数给 `then()` 方法
- 不要把 `promise` 写成嵌套

使用 `Promise.all()` 可以处理多个任务执行后再执行某个任务。

> `Promise.all(iterable)` 方法返回一个 `Promise` 实例，此实例在 `iterable` 参数内所有的 `promise` 都“完成（resolved）”或参数中不包含 `promise` 时回调完成（resolve）；如果参数中  `promise` 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 `promise` 的结果。

下面的例子中使用了 `Promise.all()` ：

```javascript
var a,b,c,d;

function f1(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            a = 1;
            console.log(`a=${a}`);
            resolve();
        },1000);
    });
}
function f2(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            b = a + 1;
            console.log(`b=${b}`);
            resolve();
        },500);
    });
}
function f3(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            c = 2;
            console.log(`c=${c}`);
            resolve();
        },1000);
    });
}
function f4(){
    return new Promise(function(resolve,reject){
        setTimeout(function(){
            d = b + c;
            console.log(`d=${d}`);
            resolve();
        },500);
    });
}

Promise.all([f1().then(function(){
    return Promise.resolve(f2());
}),f3()]).then(function(){
    return Promise.resolve(f4());
}).then(function(){
    return Promise.resolve('promise调用完毕');
}).catch(function(reason){
    console.log(`promise链调用异常：${reason}`);
});
```

`Promise` 的最大问题是代码冗余，原来的任务被 `Promise` 包装了一下，不管什么操作，一眼看去都是一堆 `then`，原来的语义变得很不清楚。那么有没有更好的写法呢

## 四、Generator

这部分内容些许复杂，在于在下的能力较差，之后再进行叙述

## 五、async/await
